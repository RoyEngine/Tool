# 重命名功能修复计划

## 一、问题分析

通过分析代码和终端日志，我发现了以下几个关键问题：

1. **JSON解析失败**：mod_info.json文件中包含注释，导致JSON解析失败
2. **重命名格式不符合要求**：当前使用mod_id作为新文件夹名称，而不是用户要求的"name + 空格 + version"格式
3. **重复读取JSON文件**：每次重命名都需要读取mod_info.json文件，导致重复的文件操作和资源消耗
4. **缺乏id与文件夹的绑定关联**：没有建立id到文件夹路径的映射关系，导致无法高效管理文件夹位置

## 二、修复计划

### 1. 修复mod_info.json解析问题

**问题**：mod_info.json文件中包含注释，导致JSON解析失败

**修复方案**：
- 修改ModInfo类的_read_mod_info方法，添加对JSON注释的支持
- 使用正则表达式或专门的JSON解析库来处理带有注释的JSON文件

**实施步骤**：
- 打开`src/init_mode/core.py`文件
- 修改ModInfo类的_read_mod_info方法，添加对JSON注释的处理
- 使用正则表达式移除JSON字符串中的注释

### 2. 修改重命名逻辑

**问题**：当前使用mod_id作为新文件夹名称，而不是用户要求的"name + 空格 + version"格式

**修复方案**：
- 修改auto_rename_files_folders函数中的重命名逻辑
- 使用"name + 空格 + version"格式构建新的文件夹名称

**实施步骤**：
- 打开`src/init_mode/core.py`文件
- 修改auto_rename_files_folders函数中的新文件夹名称构建逻辑
- 将第221行的`new_folder_name = mod_info.mod_id if mod_info.mod_id else mod_folder`改为使用"name + 空格 + version"格式

### 3. 实现缓存机制

**问题**：每次重命名都需要读取mod_info.json文件，导致重复的文件操作和资源消耗

**修复方案**：
- 实现一个缓存机制，将已读取的mod_info缓存起来
- 避免重复读取同一个mod_info.json文件

**实施步骤**：
- 在init_mode/core.py文件中添加一个全局缓存字典
- 在ModInfo类中添加缓存逻辑，先检查缓存中是否已有该文件的信息
- 如果有，直接使用缓存的信息；如果没有，读取文件并缓存

### 4. 实现id与文件夹的绑定关联

**问题**：没有建立id到文件夹路径的映射关系，导致无法高效管理文件夹位置

**修复方案**：
- 创建一个映射表，存储id到文件夹路径的映射
- 在重命名过程中更新这个映射表
- 后续操作可以直接通过id查找对应的文件夹路径，避免重复遍历目录

**实施步骤**：
- 在init_mode/core.py文件中添加一个全局映射字典
- 在重命名过程中，将mod_id与文件夹路径的映射关系保存到映射表中
- 提供一个函数来根据mod_id查找对应的文件夹路径

## 三、预期效果

1. 能够正确解析带有注释的mod_info.json文件
2. 文件夹重命名格式遵循"name + 空格 + version"的结构
3. 避免重复读取JSON文件，减少资源消耗
4. 建立id与文件夹的绑定关联，提高文件夹管理效率
5. 重命名功能更加稳定可靠，能够处理各种情况

## 四、验证计划

1. 准备带有注释的mod_info.json文件，测试解析功能
2. 运行重命名功能，检查文件夹是否按照"name + 空格 + version"格式重命名
3. 监控日志，确认不再重复读取同一个JSON文件
4. 检查id与文件夹的映射关系是否正确建立和更新
5. 验证重命名功能在各种情况下都能正常工作