# 配置文件加载失败问题修复方案

## 问题分析

### 错误信息
```
加载配置文件失败: name 'current_dir' is not defined
```

### 根本原因
1. 配置文件中使用了`${current_dir}`作为占位符，如：
   ```json
   "tool_root": "${current_dir}"
   ```

2. 在`_resolve_directory_config`方法中，代码逻辑如下：
   - 首先替换`${current_dir}`为脚本目录
   - 然后替换其他占位符（如`${mod_root}`）
   - 最后调用`os.path.expandvars(path)`替换环境变量

3. 问题出在`os.path.expandvars(path)`调用上：
   - 在Windows系统中，`os.path.expandvars`会尝试将`${current_dir}`作为环境变量进行扩展
   - 由于`current_dir`不是一个环境变量，Python 3.14会抛出`NameError`
   - 在之前的Python版本中，它只会返回空字符串，不会抛出错误

## 修复方案

### 方案1：调整代码执行顺序
确保在调用`os.path.expandvars`之前，所有`${current_dir}`占位符都已经被替换为实际路径

### 方案2：使用try-except块捕获异常
在调用`os.path.expandvars`时，使用try-except块捕获`NameError`异常

### 方案3：修改占位符格式
将配置文件中的`${current_dir}`改为`%current_dir%`（Windows风格）或其他不会被`os.path.expandvars`识别的格式

## 具体实现

我将采用方案1，调整代码执行顺序，确保在调用`os.path.expandvars`之前，所有`${current_dir}`占位符都已经被替换为实际路径

### 修复步骤
1. 修改`_resolve_directory_config`方法，确保在替换其他占位符之前，所有`${current_dir}`占位符都已经被替换为实际路径
2. 在调用`os.path.expandvars`之前，再次检查并替换所有`${current_dir}`占位符
3. 添加日志信息，便于调试

### 修复代码
```python
def _resolve_directory_config(self) -> None:
    """
    解析目录配置，替换占位符
    """
    if "directories" not in self.config:
        logger.warning("配置文件中缺少directories配置")
        # 创建默认的directories配置
        self.config["directories"] = {
            "tool_root": "${current_dir}",
            "mod_root": "${current_dir}/../Localization_File",
            "source": "${mod_root}/source",
            "output": "${mod_root}/output",
            "logs": "${tool_root}/logs",
            "rules": "${mod_root}/rule"
        }
        logger.info("已创建默认的directories配置")
    
    directories = self.config["directories"].copy()
    
    # 获取当前脚本目录作为基准
    script_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    logger.debug(f"当前脚本目录: {script_dir}")
    
    # 先替换所有${current_dir}占位符，避免os.path.expandvars报错
    for key in directories:
        if isinstance(directories[key], str) and "${current_dir}" in directories[key]:
            directories[key] = directories[key].replace("${current_dir}", script_dir)
            logger.debug(f"预替换 {key} 中的${{current_dir}}: {directories[key]}")
    
    # 计算 tool_root 的绝对路径
    tool_root = directories.get("tool_root")
    if tool_root:
        if not os.path.isabs(tool_root):
            # 如果是相对路径，基于当前脚本目录计算绝对路径
            tool_root = os.path.normpath(os.path.join(script_dir, tool_root))
            logger.debug(f"相对路径转换后 tool_root: {tool_root}")
    else:
        # 如果没有配置 tool_root，使用当前脚本的上级目录作为默认值
        tool_root = script_dir
        logger.debug(f"使用默认值 tool_root: {tool_root}")
    directories["tool_root"] = tool_root
    
    # 自动计算 mod_root(Localization_File)路径，位于 tool_root 的上级目录
    mod_root = os.path.join(os.path.dirname(tool_root), "Localization_File")
    directories["mod_root"] = mod_root
    logger.debug(f"计算得到 mod_root: {mod_root}")
    
    # 替换占位符
    for key, path in directories.items():
        if isinstance(path, str):
            original_path = path
            # 再次检查并替换${current_dir}，确保所有占位符都已被替换
            if "${current_dir}" in path:
                path = path.replace("${current_dir}", script_dir)
                logger.debug(f"再次替换 ${current_dir} 后 {key}: {path}")
            # 替换其他占位符
            for placeholder, value in directories.items():
                if isinstance(value, str):
                    placeholder_str = f"${{{placeholder}}}"
                    if placeholder_str in path:
                        path = path.replace(placeholder_str, value)
                        logger.debug(f"替换 {placeholder_str} 后 {key}: {path}")
            # 替换环境变量，使用try-except捕获异常
            try:
                expanded_path = os.path.expandvars(path)
                if expanded_path != path:
                    path = expanded_path
                    logger.debug(f"替换环境变量后 {key}: {path}")
            except NameError as e:
                logger.warning(f"替换环境变量时发生错误: {e}，将使用原始路径")
            # 规范化路径
            path = os.path.normpath(path)
            if path != original_path:
                logger.debug(f"规范化后 {key}: {path} (原路径: {original_path})")
            # 更新配置
            self.config["directories"][key] = path
```

## 修复效果

1. 确保在调用`os.path.expandvars`之前，所有`${current_dir}`占位符都已经被替换为实际路径
2. 添加了try-except块，捕获`os.path.expandvars`可能抛出的`NameError`异常
3. 增强了日志信息，便于调试
4. 提高了代码的健壮性，能够处理不同Python版本的差异

## 测试建议

1. 运行主程序，检查是否还会出现配置文件加载失败的错误
2. 检查日志信息，确保配置文件加载成功
3. 验证生成的目录路径是否正确

## 其他注意事项

1. 此修复方案兼容Python 3.14及之前的版本
2. 保留了原有的配置文件格式，不需要修改配置文件
3. 只修改了`_resolve_directory_config`方法，不会影响其他功能
4. 修复后，程序能够正确处理配置文件中的`${current_dir}`占位符